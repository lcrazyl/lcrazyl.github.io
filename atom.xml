<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IFTS</title>
  
  
  <link href="http://www.swiftslee.me/atom.xml" rel="self"/>
  
  <link href="http://www.swiftslee.me/"/>
  <updated>2021-08-21T03:33:02.271Z</updated>
  <id>http://www.swiftslee.me/</id>
  
  <author>
    <name>swiftslee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://www.swiftslee.me/2021/08/21/%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://www.swiftslee.me/2021/08/21/%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2021-08-21T03:30:09.568Z</published>
    <updated>2021-08-21T03:33:02.271Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h2 id="什么是时间和空间复杂度？"><a href="#什么是时间和空间复杂度？" class="headerlink" title="什么是时间和空间复杂度？"></a>什么是时间和空间复杂度？</h2><ul><li>时间复杂度：代码执行时间的增长变化趋势。</li><li>空间复杂度：运行过程中临时占用存储空间大小的一个量度。<h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2></li></ul><p>对于同一个问题，往往有不同的解决方案，那么也代表使用了不同的算法，那如何衡量算法之间的优劣，就要从时间和空间考虑。</p><span id="more"></span><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>这还不好说，我把程序运行一遍不就知道时间是多少了吗？为啥还要用晦涩又难懂的时间复杂度来描述呢？<br><br>不得不说这种方法可行，但如果程序在不同环境下执行，那变量可就不止执行时间那么简单了。可见要想客观的衡量程序执行时间，还得继续往下看。</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。</p></blockquote><p><font color="red">时间复杂度越大，执行的效率越低</font></p><h3 id="大O表示法："><a href="#大O表示法：" class="headerlink" title="大O表示法："></a>大O表示法：</h3><p>定义说的太官方，也难理解，那我们用这个方法试着理解一下。</p><h4 id="常数阶："><a href="#常数阶：" class="headerlink" title="常数阶："></a>常数阶：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0,n = 100;      /* 执行一次 */</span><br><span class="line">sum = (1 + n) * n / 2;    /* 执行一次 */</span><br><span class="line">printf(&quot;%d&quot;, sum);        /* 执行一次 */</span><br></pre></td></tr></table></figure><p>上方代码的时间复杂度为O(1),为什么呢？<br><br>首先来看表达式：：T(n)=O(f(n))，其中f(n)表示代码执行次数之和，上方代码为3：f(3)。但n为输入数据的长度，因此无论n多大，执行次数是不变的，因此我们说时间复杂度为O(1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let n = 10;</span><br><span class="line">console.log(10);</span><br><span class="line"></span><br><span class="line">let n = 100;</span><br><span class="line">console.log(n);</span><br></pre></td></tr></table></figure><p>如果还不懂，那现在呢？无论n的值是多少，执行次数是不变的。</p><h4 id="线性阶："><a href="#线性阶：" class="headerlink" title="线性阶："></a>线性阶：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i&lt;=n;i++)&#123;  //执行n次</span><br><span class="line">    //O(1)程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码，随着n的变化，程序运行时间也在相应变化，因此此时的时间复杂度为O(n)。</p><h4 id="平方阶："><a href="#平方阶：" class="headerlink" title="平方阶："></a>平方阶：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i&lt;n;i++)&#123;</span><br><span class="line">    for(let j = 0;j&lt;n;j++)&#123;</span><br><span class="line">        //O(1)程序代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码就是循环嵌套，程序执行时间随着两个for的循环次数变化而变化，因此时间复杂度为O(n*n)，即循环次数乘循环体复杂度。</p><h4 id="推导大O阶："><a href="#推导大O阶：" class="headerlink" title="推导大O阶："></a>推导大O阶：</h4><ol><li>用常数1取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li></ol><h4 id="常见时间复杂度表："><a href="#常见时间复杂度表：" class="headerlink" title="常见时间复杂度表："></a>常见时间复杂度表：</h4><table><thead><tr><th>执行次数</th><th>函数阶</th><th>非正式术语</th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr><td>3n2+2n+1</td><td>O(n<sup>2</sup>)</td><td>平方阶</td></tr><tr><td>5log<sub>2</sub>n+20</td><td>O(logn)</td><td>对数阶</td></tr><tr><td>2n+3nlog<sub>2</sub>n+19</td><td>O(nlogn)</td><td>nlogn阶</td></tr><tr><td>6n<sup>3</sup>+2n<sup>2</sup>+3n+4</td><td>O(n3)</td><td>立方阶</td></tr><tr><td>2<sup>n</sup></td><td>O(2n)</td><td>指数阶</td></tr></tbody></table><hr><h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><blockquote><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p></blockquote><p>我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h2 id=&quot;什么是时间和空间复杂度？&quot;&gt;&lt;a href=&quot;#什么是时间和空间复杂度？&quot; class=&quot;headerlink&quot; title=&quot;什么是时间和空间复杂度？&quot;&gt;&lt;/a&gt;什么是时间和空间复杂度？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;时间复杂度：代码执行时间的增长变化趋势。&lt;/li&gt;
&lt;li&gt;空间复杂度：运行过程中临时占用存储空间大小的一个量度。&lt;h2 id=&quot;有什么用？&quot;&gt;&lt;a href=&quot;#有什么用？&quot; class=&quot;headerlink&quot; title=&quot;有什么用？&quot;&gt;&lt;/a&gt;有什么用？&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于同一个问题，往往有不同的解决方案，那么也代表使用了不同的算法，那如何衡量算法之间的优劣，就要从时间和空间考虑。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.swiftslee.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="时间复杂度" scheme="http://www.swiftslee.me/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>基本类型和引用类型</title>
    <link href="http://www.swiftslee.me/2021/08/21/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.swiftslee.me/2021/08/21/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-08-21T03:29:02.540Z</published>
    <updated>2021-08-21T03:34:50.889Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h2 id="基本类型和引用类型是什么？"><a href="#基本类型和引用类型是什么？" class="headerlink" title="基本类型和引用类型是什么？"></a>基本类型和引用类型是什么？</h2><ul><li>基本类型包括：<ul><li>number</li><li>string</li><li>boolean</li><li>undefined</li><li>null</li></ul></li><li>引用类型：除了基本类型之外的。<span id="more"></span><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><h4 id="存储位置："><a href="#存储位置：" class="headerlink" title="存储位置："></a>存储位置：</h4></li><li>基本类型保存在栈中，且进行比较时，比较的时值</li><li>引用类型同时保存在栈和堆中，其中栈保存地址，堆保存数据，且进行比较时，比较的是地址</li></ul><p>这在说啥呢？又是堆又是栈，请继续看。</p><h4 id="什么是栈、堆？"><a href="#什么是栈、堆？" class="headerlink" title="什么是栈、堆？"></a>什么是栈、堆？</h4><ul><li>栈：由系统自动分配释放，存储函数的参数值、局部变量等，访问速度块。</li><li>堆：由开发人员分配释放，访问速度慢。<blockquote><p>简单来说栈就像租房，可以领包入住，不需要考虑房间的布局、地板的颜色；而堆就像自己动手装修，要考虑房间布局、整体色调。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = 10;</span><br><span class="line">console.log(a===b) //true or false?</span><br></pre></td></tr></table></figure><p>答案肯定是<code>true</code>，因为基本类型是保存在栈中的，而且比较的是值，如下图：<br><img src="https://cdn.jsdelivr.net/gh/lcrazyl/image/image/20210820171035.png" alt="基本类型"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj1 =&#123;&#125;;</span><br><span class="line">let obj2 = &#123;&#125;;</span><br><span class="line">console.log(a===b) //true or false?</span><br></pre></td></tr></table></figure><p>答案是<code>false</code>,因为引用类型将地址保存在栈中，显然二者的地址是不同的，如下图：<br><img src="https://cdn.jsdelivr.net/gh/lcrazyl/image/image/20210820171252.png" alt="引用类型"></p><h3 id="保存方式："><a href="#保存方式：" class="headerlink" title="保存方式："></a>保存方式：</h3><ul><li>引用类型：当声明一个对象时，会将该对象的地址保存在栈内存；当给变量赋值时，会在堆内存开辟一个空间，并把值保存在堆内存，与此同时，栈内存里的地址指向堆内存里的值。</li><li>基本类型：当声明变量时，会在栈内存开辟一个空间将变量值保存在栈内。</li></ul><hr><h2 id="深浅拷贝："><a href="#深浅拷贝：" class="headerlink" title="深浅拷贝："></a>深浅拷贝：</h2><h4 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h4><p>当对某个数据进行拷贝时，生成的新数据会和原数据相关联，也就是修改原数据或新数据都会相互影响。<br><br><font color="red">浅拷贝只是复制值。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line">function shallowCopy(target) &#123;</span><br><span class="line">  let newArr = [];</span><br><span class="line">  for (item in target) &#123;</span><br><span class="line">    newArr[item] = target[item];</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newArr = shallowCopy(arr);</span><br><span class="line">console.log(&quot;原数据：&quot; + arr);//1,2,3,4</span><br><span class="line">console.log(&quot;新数据：&quot; + newArr);//1,2,3,4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那我们现在看如下实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> let obj = &#123;</span><br><span class="line">   name: &quot;harry&quot;,</span><br><span class="line">   age: 20,</span><br><span class="line">   sleep: &#123;</span><br><span class="line">     after: &quot;one&quot;,</span><br><span class="line">     evening: &quot;two&quot;,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br><span class="line">function shallowCopy(target) &#123;</span><br><span class="line">   let newObj = &#123;&#125;;</span><br><span class="line">   for (let item in target) &#123;</span><br><span class="line">     newObj[item] = target[item];</span><br><span class="line">   &#125;</span><br><span class="line">   return newObj;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> console.log(obj);//after:&quot;11&quot;</span><br><span class="line"> let newObj = shallowCopy(obj);</span><br><span class="line"> obj.sleep.after = &quot;11&quot;;</span><br><span class="line"> console.log(newObj);//after:&quot;11&quot;</span><br></pre></td></tr></table></figure><p>我们发现，通过改变obj里面的数据，newObj里面的数据也在发生变化，这显然不是我们想要的。</p><h4 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h4><p>深拷贝是拷贝一个独立的对象，不仅会拷贝数据，还会拷贝地址。</p><pre><code> let obj = &#123;        name: &quot;harry&quot;,        age: 20,        sleep: &#123;          after: &quot;one&quot;,          evening: &quot;two&quot;,        &#125;,      &#125;;    function deepCopy(target) &#123;          let newObj = &#123;&#125;;          for (item in target) &#123;            if (typeof target[item] === &quot;object&quot; &amp;&amp; target[item] != null) &#123;              newObj[item] = deepCopy(target[item]);            &#125; else &#123;              newObj[item] = target[item];            &#125;          &#125;          return newObj;        &#125;        console.log(obj);//after:&quot;11&quot;        let newObj = deepCopy(obj);        obj.sleep.after = &quot;11&quot;;        console.log(newObj);//after:&quot;one&quot;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h2 id=&quot;基本类型和引用类型是什么？&quot;&gt;&lt;a href=&quot;#基本类型和引用类型是什么？&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型是什么？&quot;&gt;&lt;/a&gt;基本类型和引用类型是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基本类型包括：&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;引用类型：除了基本类型之外的。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://www.swiftslee.me/categories/JavaScript/"/>
    
    
    <category term="数据类型" scheme="http://www.swiftslee.me/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>线性递归</title>
    <link href="http://www.swiftslee.me/2021/08/19/%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92/"/>
    <id>http://www.swiftslee.me/2021/08/19/%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92/</id>
    <published>2021-08-19T12:45:15.672Z</published>
    <updated>2021-08-19T12:49:40.456Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h2 id="何为递归？"><a href="#何为递归？" class="headerlink" title="何为递归？"></a>何为递归？</h2><blockquote><p>递归其实就是迭代的语法糖，曾看过这么一个解释：递归就像查字典，为了解释一个词往往需要使用更多的词。当开始查一个字的时候，发现不懂又去查另一个词，如此循环往复，直到有一个能够看明白的词，那么也代表着递归的结束。</p></blockquote><p>递归有许多分类，如线性递归、二分递归、尾递归、互递归、嵌套递归，在此只讨论线性递归。</p><h2 id="递归的优缺点？"><a href="#递归的优缺点？" class="headerlink" title="递归的优缺点？"></a>递归的优缺点？</h2><p>优点则是代码简洁，尤其遍历树；<br><br>缺点则是对于时间和空间的消耗,每一次调用都需要在内存栈分配空间保存参数等；其次可能会造成栈溢出；</p><span id="more"></span><h2 id="如何递归？"><a href="#如何递归？" class="headerlink" title="如何递归？"></a>如何递归？</h2><p>每次用递归算法建议遵循以下三要素。</p><h3 id="递归三要素："><a href="#递归三要素：" class="headerlink" title="递归三要素："></a>递归三要素：</h3><h4 id="1-明确所要解决的问题"><a href="#1-明确所要解决的问题" class="headerlink" title="1. 明确所要解决的问题"></a>1. 明确所要解决的问题</h4><h4 id="2-找出中止条件"><a href="#2-找出中止条件" class="headerlink" title="2. 找出中止条件"></a>2. 找出中止条件</h4><h4 id="3-找出等价关系"><a href="#3-找出等价关系" class="headerlink" title="3. 找出等价关系"></a>3. 找出等价关系</h4><p>百闻不如一见，那来实践一下吧。</p><h4 id="递归实现阶乘"><a href="#递归实现阶乘" class="headerlink" title="递归实现阶乘"></a>递归实现阶乘</h4><p>问题描述：输入一个数字，返回所有小于及等于该数的正整数的积<br><br>第一步，要明确解决的是什么问题。显然，我们想要实现一个阶乘算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fac(num)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经完成了第一步，接下来是找出中止条件。前文用查字典比喻递归，如果你一直找不到一个能理解的词，那就会一直查下去。递归也是如此，如果找不出中止条件，就会一直调用，进入死循环。<br><br>因此，对于阶乘我们显然知道：当num=1时结果为1，即fac(1)=1，那我们继续编写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fac(num)&#123;</span><br><span class="line">    if(num===1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步也已经完成，只剩下最后一步，也是最难的一步。我们如何找出等价关系呢？就要缩小范围，把抽象变得具体一点，比如当fac(num)时，阶乘就是n*fac(num-1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fac(num)&#123;</span><br><span class="line">    if(num===1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n*fac(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么阶乘的递归算法也就完成了，那他内部到底怎么计算的呢？请看下图：<br><img src="https://cdn.jsdelivr.net/gh/lcrazyl/image/image/20210818202325.png" alt="递归"></p><h4 id="递归实现棋盘问题"><a href="#递归实现棋盘问题" class="headerlink" title="递归实现棋盘问题"></a>递归实现棋盘问题</h4><p>问题描述：有一个棋盘 棋盘上有16个格子 第一个格子有一粒芝麻第二个格子有两粒芝麻第三个格子有四粒芝麻 第四个格子有八粒芝麻后续格子依次翻倍求总共有多少粒芝麻。<br><br>第一步，明确解决什么问题。我们要求十六个格子芝麻之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Sesame(num)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sesame(16);</span><br></pre></td></tr></table></figure><p>第一步搞定，进入第二步，中止条件是什么呢？显然题目已经给出，第一个格子有一粒芝麻，因此Sesame(1)=1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Sesame(num)&#123;</span><br><span class="line">   if(num===1)&#123;</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Sesame(16);</span><br></pre></td></tr></table></figure><p>第二步也大功告成，第三步则是找等价条件，我们不难发现，肯定和2的倍数有关。是不是2*Sesame(num-1)呢？我们试一试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Sesame(num)&#123;</span><br><span class="line">   if(num===1)&#123;</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   return 2*Sesame(num-1);</span><br><span class="line">&#125;</span><br><span class="line">Sesame(16);</span><br></pre></td></tr></table></figure><p>我们验证一下，当num=2时返回2，但要求的是总量，应该为3啊，为什么错了呢？因为我们现在求的是每个芝麻的数量，总量应该是2*Sesame(num-1)+1，现在没问题了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Sesame(num)&#123;</span><br><span class="line">   if(num===1)&#123;</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   return 2*Sesame(num-1)+1;</span><br><span class="line">&#125;</span><br><span class="line">Sesame(16);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h2 id=&quot;何为递归？&quot;&gt;&lt;a href=&quot;#何为递归？&quot; class=&quot;headerlink&quot; title=&quot;何为递归？&quot;&gt;&lt;/a&gt;何为递归？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;递归其实就是迭代的语法糖，曾看过这么一个解释：递归就像查字典，为了解释一个词往往需要使用更多的词。当开始查一个字的时候，发现不懂又去查另一个词，如此循环往复，直到有一个能够看明白的词，那么也代表着递归的结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归有许多分类，如线性递归、二分递归、尾递归、互递归、嵌套递归，在此只讨论线性递归。&lt;/p&gt;
&lt;h2 id=&quot;递归的优缺点？&quot;&gt;&lt;a href=&quot;#递归的优缺点？&quot; class=&quot;headerlink&quot; title=&quot;递归的优缺点？&quot;&gt;&lt;/a&gt;递归的优缺点？&lt;/h2&gt;&lt;p&gt;优点则是代码简洁，尤其遍历树；&lt;br&gt;&lt;br&gt;缺点则是对于时间和空间的消耗,每一次调用都需要在内存栈分配空间保存参数等；其次可能会造成栈溢出；&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.swiftslee.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="http://www.swiftslee.me/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>作用域与函数</title>
    <link href="http://www.swiftslee.me/2021/08/19/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>http://www.swiftslee.me/2021/08/19/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0/</id>
    <published>2021-08-19T12:34:30.904Z</published>
    <updated>2021-08-21T03:33:42.850Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h2 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h2><p>众所周知，js作用域分为两类：全局作用域和局部（函数）作用域。</p><ul><li>全局作用域：即在<code>script</code>定义的变量。</li><li>局部作用域：在函数内部定义的变量。</li></ul><p>js规定了函数内部可以访问全局变量，而外部无法访问局部变量。</p><span id="more"></span><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><ul><li><code>var</code>：由<code>var</code>声明的变量属于全局变量，在函数内声明则是局部变量。并且<code>var</code>会有变量提升。</li><li><code>let</code>，由<code>let</code>声明的变量属于块级变量，即大括号。所以大括号之外的区域不可访问，且不会被提升。</li><li><code>const</code>：由<code>const</code>声明的变量也属于块级变量，且由它声明的变量会锁定，不可以进行重新赋值，但可以被更改。</li></ul><h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><blockquote><p>函数实际上是对象，每个函数都是Function实例，而函数名就是指向函数对象的指针。</p></blockquote><h2 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a>函数定义：</h2><ul><li>函数声明：(最后没有分号)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sayHello()&#123;</span><br><span class="line">    let message = &quot;hello!&quot;</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数表达式：（最后有分号）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sayHello = function()&#123;</span><br><span class="line">    let message = &quot;hello!&quot;</span><br><span class="line">    return message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>构造函数：（不推荐）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let sayHello = new Function()&#123;</span><br><span class="line">    let message = &quot;hello!&quot;</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br><span class="line">//箭头函数</span><br><span class="line">let sayHello = ()=&gt;&#123;</span><br><span class="line">    let message = &quot;hello!&quot;</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br><span class="line">//箭头函数则是上方的构造函数</span><br></pre></td></tr></table></figure><p>构造函数声明不推荐是因为会被解释两次：第一次是当作常规代码执行，第二次是解释传给构造函数。</p><h2 id="箭头函数缺点：-以下都不能使用"><a href="#箭头函数缺点：-以下都不能使用" class="headerlink" title="箭头函数缺点：(以下都不能使用)"></a>箭头函数缺点：(以下都不能使用)</h2><ul><li>arguments</li><li>super</li><li>prototype</li></ul><h2 id="函数名："><a href="#函数名：" class="headerlink" title="函数名："></a>函数名：</h2><p>函数名就是指向函数的指针，因此一个函数可以有多个名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">let sum1 = sum();</span><br></pre></td></tr></table></figure><p>但下面的赋值代表着什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sum2= sum;</span><br></pre></td></tr></table></figure><p>是给将该函数赋值给了sum2吗？显然不是。上文已经提到，函数就是对象。<br><br><font color="red">使用不带括号的函数名会访问函数指针，指向相同的函数，且不会执行该函数。</font></p><h2 id="函数参数："><a href="#函数参数：" class="headerlink" title="函数参数："></a>函数参数：</h2><p>JavaScript参数有所不同，它不关心参数的多少、类型，<font color="red"> 因为在函数内部，参数表现为一个数组</font>。因此有了<code>arguments</code><br><code>arguments</code>可以访问到传递给函数的所有参数，它是一个伪数组，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function a(num) &#123;</span><br><span class="line">  for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    console.log(arguments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a(1, 2, 3, 4);</span><br></pre></td></tr></table></figure><h2 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h2><blockquote><p>闭包就是间接访问变量或者隐藏变量。</p></blockquote><h3 id="闭包作用："><a href="#闭包作用：" class="headerlink" title="闭包作用："></a>闭包作用：</h3><ul><li>访问函数局部变量</li><li>让变量保存在内存中<h2 id="闭包实例："><a href="#闭包实例：" class="headerlink" title="闭包实例："></a>闭包实例：</h2></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（</span><br><span class="line">var a = 10;</span><br><span class="line">function num()&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"> console.log(num()); //10</span><br></pre></td></tr></table></figure><p>函数访问到了a变量，因此函数和能够访问到的变量就是闭包。外部是一个立即执行函数访问到了a变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var local = 1;</span><br><span class="line">  foo1 = function () &#123;</span><br><span class="line">    local++;</span><br><span class="line">    return local;</span><br><span class="line">  &#125;;</span><br><span class="line">  return foo1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = foo();  //2 第一次执行foo1</span><br><span class="line">console.log(func());</span><br><span class="line">foo1();  //4 第二次执行foo2</span><br><span class="line">console.log(func());</span><br></pre></td></tr></table></figure><p>上方代码也是闭包，也是经常看到的函数嵌套函数。由此可见，foo访问到了foo1的local变量，这就是闭包。并且，在foo执行完后，local变量没有消失，而是保存在了内存里。<br><br>因为foo1依赖于foo，并且foo1是全局变量。所以foo1始终存在，因此foo也始终存在。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this在标准函数中："><a href="#this在标准函数中：" class="headerlink" title="this在标准函数中："></a>this在标准函数中：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Window.color=&quot;red&quot;;</span><br><span class="line">let o = &#123;</span><br><span class="line">    color:&#x27;blue&#x27;;  </span><br><span class="line">&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();//red</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();//blue</span><br></pre></td></tr></table></figure><p>上面代码中函数<code>sayColor</code>运用了<code>this</code>。<font color="red"><code>this</code>到底引用哪个对象，要到函数被调用时才能确定。</font><br></p><ul><li><code>sayColor()</code>之所以是red，因为此时这个方法的调用是在全局上下文中，因此指向<code>Window</code>。</li><li><code>o.sayColor()</code>之所以是blue，是因为把函数<code>sayColor</code>赋给了o，因此this指向o。<h3 id="this在箭头函数中："><a href="#this在箭头函数中：" class="headerlink" title="this在箭头函数中："></a>this在箭头函数中：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Window.color=&quot;red&quot;;</span><br><span class="line">let o = &#123;</span><br><span class="line">    color:&#x27;blue&#x27;;  </span><br><span class="line">&#125;;</span><br><span class="line">function sayColor=&gt;()&#123;</span><br><span class="line">    console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();//red</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();//red</span><br></pre></td></tr></table></figure>此时，两次都指向<code>Window</code>，因为<font color="red">箭头函数是在全局上下文定义的</font>。<br>箭头函数中，this的指向会保留定义函数的上下文。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h2 id=&quot;作用域：&quot;&gt;&lt;a href=&quot;#作用域：&quot; class=&quot;headerlink&quot; title=&quot;作用域：&quot;&gt;&lt;/a&gt;作用域：&lt;/h2&gt;&lt;p&gt;众所周知，js作用域分为两类：全局作用域和局部（函数）作用域。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局作用域：即在&lt;code&gt;script&lt;/code&gt;定义的变量。&lt;/li&gt;
&lt;li&gt;局部作用域：在函数内部定义的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;js规定了函数内部可以访问全局变量，而外部无法访问局部变量。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://www.swiftslee.me/categories/JavaScript/"/>
    
    
    <category term="函数" scheme="http://www.swiftslee.me/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSS兼容问题总结</title>
    <link href="http://www.swiftslee.me/2021/08/12/CSS%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.swiftslee.me/2021/08/12/CSS%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-12T11:53:27.163Z</published>
    <updated>2021-08-21T03:36:14.561Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1-图片边框"><a href="#1-图片边框" class="headerlink" title="1. 图片边框"></a>1. 图片边框</h2><p>问题描述：当a标签嵌套图片时出现边框<br><br>解决方案：图片加<code>boder:0/none</code>;</p><h2 id="2-图片间隙"><a href="#2-图片间隙" class="headerlink" title="2. 图片间隙"></a>2. 图片间隙</h2><p>问题描述：<code>block</code>元素牵嵌套图片在不加高度情况下，图片下方出现三像素<br></p><span id="more"></span><p>解决方案：图片添加<code>vertical-aligin:center/display:block</code>/父元素添加<code>font-size:0</code></p><h2 id="3-双倍浮动"><a href="#3-双倍浮动" class="headerlink" title="3.双倍浮动"></a>3.双倍浮动</h2><p>问题描述：解析浮动元素时，错误的把<code>margin</code>双倍显示。（IE6以下）<br><br>解决方案：浮动元素添加<code>display:inline;</code></p><h2 id="4-默认高度"><a href="#4-默认高度" class="headerlink" title="4.默认高度"></a>4.默认高度</h2><p>问题描述：部分块元素拥有默认高度（20像素左右）（IE6以下）<br><br>解决方案：元素添加<code>font-size:0</code>/<code>overflow:hidden;height:0(如果有高度，不要设置）</code>(IE6/7)</p><h2 id="5-表单元素对齐不一致"><a href="#5-表单元素对齐不一致" class="headerlink" title="5. 表单元素对齐不一致"></a>5. 表单元素对齐不一致</h2><p>问题描述：表单元素顶部对齐不一致<br><br>解决方案：表单元素添加<code>float:left</code></p><h2 id="6-按钮元素默认大小不一致"><a href="#6-按钮元素默认大小不一致" class="headerlink" title="6.按钮元素默认大小不一致"></a>6.按钮元素默认大小不一致</h2><p>问题描述：各浏览器按钮元素大小不一致。<br><br>解决方案：用<code>a</code>标签；按钮转为标准盒模型；<code>input</code>外嵌套标签,写按钮样式且去掉<code>input</code>边框。</p><h2 id="7-透明属性"><a href="#7-透明属性" class="headerlink" title="7.透明属性"></a>7.透明属性</h2><p>问题描述：透明共有三种写法：<code>opacity:0-1</code>/<code>rgba(r,g.b,a)</code>/<code>filter:alpha(opacity=1-100)</code><br><br>解决方案：<code>filter</code>属性是IE特有的透明属性,其他两种方案只有IE9以上识别。</p><h2 id="8-表单边框清除"><a href="#8-表单边框清除" class="headerlink" title="8.表单边框清除"></a>8.表单边框清除</h2><p>问题描述：清除边框bug（IE6以下）<br><br>解决方案：使用<code>border:0</code></p><h2 id="9-表单value值不居中"><a href="#9-表单value值不居中" class="headerlink" title="9. 表单value值不居中"></a>9. 表单<code>value</code>值不居中</h2><p>问题描述；当表单添加高度属性，且有<code>value</code>属性时，会<code>value</code>值垂直布局中问题（IE6以下）<br><br>解决方案：<code>input</code>添加`_line-height</p><h2 id="10-多张图片间隙"><a href="#10-多张图片间隙" class="headerlink" title="10. 多张图片间隙"></a>10. 多张图片间隙</h2><p>问题描述：<code>inline/inline-block</code>元素都会有此问题<br><br>解决方案：图片添加<code>float</code>属性/父元素添加<code>font-size:0</code></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;1-图片边框&quot;&gt;&lt;a href=&quot;#1-图片边框&quot; class=&quot;headerlink&quot; title=&quot;1. 图片边框&quot;&gt;&lt;/a&gt;1. 图片边框&lt;/h2&gt;&lt;p&gt;问题描述：当a标签嵌套图片时出现边框&lt;br&gt;&lt;br&gt;解决方案：图片加&lt;code&gt;boder:0/none&lt;/code&gt;;&lt;/p&gt;
&lt;h2 id=&quot;2-图片间隙&quot;&gt;&lt;a href=&quot;#2-图片间隙&quot; class=&quot;headerlink&quot; title=&quot;2. 图片间隙&quot;&gt;&lt;/a&gt;2. 图片间隙&lt;/h2&gt;&lt;p&gt;问题描述：&lt;code&gt;block&lt;/code&gt;元素牵嵌套图片在不加高度情况下，图片下方出现三像素&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://www.swiftslee.me/categories/CSS/"/>
    
    
    <category term="CSS兼容" scheme="http://www.swiftslee.me/tags/CSS%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>弹性盒详解</title>
    <link href="http://www.swiftslee.me/2021/08/11/%E5%BC%B9%E6%80%A7%E7%9B%92/"/>
    <id>http://www.swiftslee.me/2021/08/11/%E5%BC%B9%E6%80%A7%E7%9B%92/</id>
    <published>2021-08-11T12:35:34.474Z</published>
    <updated>2021-08-21T03:37:04.047Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h1 id="什么是弹性盒？"><a href="#什么是弹性盒？" class="headerlink" title="什么是弹性盒？"></a>什么是弹性盒？</h1><p>弹性盒即弹性布局，将盒子转为弹性布局（<code>display:flex</code>）后进行排列。</p><h1 id="相关属性："><a href="#相关属性：" class="headerlink" title="相关属性："></a>相关属性：</h1><p>因为属性太多，个别属性很少用到，因此本文将只介绍常用属性值。</p><h4 id="添加给父元素："><a href="#添加给父元素：" class="headerlink" title="添加给父元素："></a>添加给父元素：</h4><ul><li><code>flex-direction</code>:决定主轴方向（排列方式）<ul><li><code>row</code>：横向排列（x轴,默认值）</li><li><code>column</code>：竖向配列（y轴）<span id="more"></span><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811202126.png" alt="主轴竖向" style="zoom: 80%;"></li><li><code>row-reverse</code>：横向倒序<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811202156.png" alt="主轴横向倒序" style="zoom:80%;"></li><li><code>column-reverse</code>：竖向倒序<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811202211.png" alt="主轴竖向倒序" style="zoom:80%;"></li></ul></li><li><code>flex-wrap</code>:子元素是否换行<ul><li><code>nowrap</code>:不换行（默认值）</li><li><code>wrap</code>:换行<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811202526.png" alt="换行" style="zoom:80%;"></li><li><code>wrap-reverse</code>:倒序换行<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811202550.png" alt="倒序换行" style="zoom:80%;"></li></ul></li><li><code>justify-content</code>:子元素在主轴对齐方式<ul><li><code>flex-start</code>:开头对齐（默认值）</li><li><code>center</code>:居中对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811202955.png" alt="主轴居中对齐" style="zoom:80%;"></li><li><code>flex-end</code>:结尾对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811203001.png" alt="主轴结尾对齐" style="zoom:80%;"></li><li><code>space-between</code>:两端对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811203031.png" alt="两端对齐" style="zoom:80%;"></li><li><code>space-aronud</code>:平分对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811203054.png" alt="平分对齐" style="zoom:80%;"></li><li><code>space-evenly</code>:均分对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811203105.png" alt="均分对齐" style="zoom:80%;"></li></ul></li><li><code>align-items</code>：子元素在交叉轴对齐方式<ul><li><code>flex-start</code>:开头对齐（默认值）</li><li><code>center</code>:居中对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811203321.png" alt="侧轴居中对齐" style="zoom:80%;"></li><li><code>flex-end</code>:结尾对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811203346.png" alt="侧轴结尾对齐" style="zoom:80%;"></li><li><code>baseline</code>:基线对齐</li><li><code>stretch</code>:拉伸（默认值）</li></ul></li></ul><h4 id="添加给子元素："><a href="#添加给子元素：" class="headerlink" title="添加给子元素："></a>添加给子元素：</h4><ul><li><code>align-self</code>:单一子元素在交叉轴对齐方式<ul><li><code>auto</code>：继承父元素<code>align-items</code>（默认值）</li><li><code>stretch</code>:拉伸</li><li><code>flex-start</code>：开头对齐</li><li><code>center</code>：居中对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811205138.png" alt="居中对齐" style="zoom:80%;"></li><li><code>flex-end</code>：结尾对齐<img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210811205206.png" alt="结尾对齐" style="zoom:80%;"></li></ul></li><li><code>flex</code>:子元素如何分配空间(复合属性：<code>flex-grow</code>/<code>flex-shrink</code>/<code>flex-basis</code>)<ul><li> <code>flex:1</code>==1 1 0%</li><li><code>flex:auto</code>==1 1 auto</li><li><code>flex:0 auto</code>==0 1 auto(默认值)</li></ul><hr><h2 id="flex-1到底代表什么？"><a href="#flex-1到底代表什么？" class="headerlink" title="flex:1到底代表什么？"></a><code>flex:1</code>到底代表什么？</h2>上文只是简单说明了<code>flex</code>代表三个值，那这三个值分别代表什么呢？</li></ul><ol><li>第一个值为放大属性<code>flex-grow</code>:默认值为0，父元素有剩余空间且值大于0时进行放大，即把剩余空间按照所给定的值均分。</li><li>第二个值为缩小属性<code>flex-shrink</code>:默认值为1，父元素空间不足且值大于1时进行缩小。</li><li>第三个值为元素宽度<code>flex-basis</code></li></ol><p>既然已经了解三个值代表什么，那<code>flex: 1 1 0%</code>即<code>flex:1</code>是不是代表1 1 auto?<br>答案是否定的，<code>auto</code>代表元素本身大小，如果设置为<code>auto</code>则会根据自身进行缩放。<br>因此，<font color="red"><code>flex:1</code>代表<code>flex:1 1 </code>任意数字+任意单位</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h1 id=&quot;什么是弹性盒？&quot;&gt;&lt;a href=&quot;#什么是弹性盒？&quot; class=&quot;headerlink&quot; title=&quot;什么是弹性盒？&quot;&gt;&lt;/a&gt;什么是弹性盒？&lt;/h1&gt;&lt;p&gt;弹性盒即弹性布局，将盒子转为弹性布局（&lt;code&gt;display:flex&lt;/code&gt;）后进行排列。&lt;/p&gt;
&lt;h1 id=&quot;相关属性：&quot;&gt;&lt;a href=&quot;#相关属性：&quot; class=&quot;headerlink&quot; title=&quot;相关属性：&quot;&gt;&lt;/a&gt;相关属性：&lt;/h1&gt;&lt;p&gt;因为属性太多，个别属性很少用到，因此本文将只介绍常用属性值。&lt;/p&gt;
&lt;h4 id=&quot;添加给父元素：&quot;&gt;&lt;a href=&quot;#添加给父元素：&quot; class=&quot;headerlink&quot; title=&quot;添加给父元素：&quot;&gt;&lt;/a&gt;添加给父元素：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flex-direction&lt;/code&gt;:决定主轴方向（排列方式）&lt;ul&gt;
&lt;li&gt;&lt;code&gt;row&lt;/code&gt;：横向排列（x轴,默认值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt;：竖向配列（y轴）&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://www.swiftslee.me/categories/CSS/"/>
    
    
    <category term="弹性盒" scheme="http://www.swiftslee.me/tags/%E5%BC%B9%E6%80%A7%E7%9B%92/"/>
    
  </entry>
  
  <entry>
    <title>元素水平垂直居中方法总结</title>
    <link href="http://www.swiftslee.me/2021/08/11/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/"/>
    <id>http://www.swiftslee.me/2021/08/11/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/</id>
    <published>2021-08-11T11:24:16.167Z</published>
    <updated>2021-08-21T03:36:53.310Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><ol><li>定位+<code>margin:auto</code>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父元素位--&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    &lt;!--任意定位--&gt;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--子元素--&gt;</span><br><span class="line">.connect&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span></li><li>定位+<code>margin:-number</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父元素--&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--子元素--&gt;</span><br><span class="line">.connect&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    &lt;!--</span><br><span class="line">    margin-left:-50px;</span><br><span class="line">    margin-top:-50px;</span><br><span class="line">    --&gt;</span><br><span class="line">    margin: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定位+<code>transform</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父元素--&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--子元素--&gt;</span><br><span class="line">.connect&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    &lt;!--position: relative/absolute--&gt;</span><br><span class="line">    position: relative;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50px,-50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>4.弹性盒（父元素）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父元素--&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.弹性盒（子元素）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父元素--&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content: center;  </span><br><span class="line">&#125;</span><br><span class="line">&lt;!--子元素--&gt;</span><br><span class="line">.connect&#123;</span><br><span class="line">     align-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.<code>vertical-align: middle</code>:</p><pre><code>&lt;!--父元素--&gt;.box&#123;    width: 300px;    height: 300px;    text-align: center;&#125;&lt;!--当前元素--&gt;.connect&#123;    &lt;!--转行内块--&gt;    display: inline-block;    vertical-align: middle;&#125;&lt;!--当前元素兄弟元素且结构同行--&gt;.connect-bro&#123;    &lt;!--与父同高且转为行内块--&gt;    height: 300px;    display: inline-block;    vertical-align: middle;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定位+&lt;code&gt;margin:auto&lt;/code&gt;:&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--父元素位--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.box&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;!--任意定位--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    position: relative;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--子元素--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.connect&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    position: absolute;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    top: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    left: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bottom: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    right: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    margin: auto;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://www.swiftslee.me/categories/CSS/"/>
    
    
    <category term="水平垂直对齐" scheme="http://www.swiftslee.me/tags/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>CSS3-过渡变形与动画</title>
    <link href="http://www.swiftslee.me/2021/08/04/CSS%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.swiftslee.me/2021/08/04/CSS%E5%8A%A8%E7%94%BB/</id>
    <published>2021-08-04T00:11:08.263Z</published>
    <updated>2021-08-21T03:36:05.735Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="过渡-transition-："><a href="#过渡-transition-：" class="headerlink" title="过渡(transition)："></a>过渡(<code>transition</code>)：</h2><blockquote><p>CSS3允许属性在一定时间内平滑过渡，过渡需要添加触发条件。</p></blockquote><h3 id="相关属性值："><a href="#相关属性值：" class="headerlink" title="相关属性值："></a>相关属性值：</h3><ul><li><p><code>transition-property</code>：检索或设置对象参与过渡的属性值；</p></li><li><p><code>transition-duration</code>：检索或设置对象过渡持续时间；</p></li><li><p><code>transition-delay</code>:检索或设置对象延迟过渡时间；</p></li><li><p><code>transition-timing-function</code>:检索或设置对象过渡动画类型；</p><span id="more"></span><ul><li><code>linear</code>:匀速；</li><li><code>ease</code>：逐渐慢下来；</li><li><code>ease-in</code>：加速；</li><li><code>ease-out</code>：减速;</li><li><code>ease-in-out</code>：先加速后减速</li></ul></li></ul><p><font color="red">属性值顺序可以调换，但过渡时间和延迟时间有先后顺序，在前的为过渡时间。</font></p><h2 id="2D变形属性：transform"><a href="#2D变形属性：transform" class="headerlink" title="2D变形属性：transform"></a>2D变形属性：<code>transform</code></h2><h3 id="相关属性："><a href="#相关属性：" class="headerlink" title="相关属性："></a>相关属性：</h3><ul><li><code>translate()</code>：位移</li><li><code>scale()</code>:缩放</li><li><code>rotate()</code>：旋转</li><li><code>skew()</code>：倾斜</li></ul><h3 id="变形原点："><a href="#变形原点：" class="headerlink" title="变形原点："></a>变形原点：</h3><blockquote><p>通常默认变形原点为元素的中心点。</p></blockquote><p><code>transform-origin</code>属性即可设置变形原点，只对<code>rotate</code>、<code>scale</code>、<code>skew</code>有效,可以用英文单词、百分数、具体像素设置。例如设置<code>transform-origin:left bottom</code>即变形原点为左下。</p><h3 id="属性详解："><a href="#属性详解：" class="headerlink" title="属性详解："></a>属性详解：</h3><ul><li><h4 id="位移："><a href="#位移：" class="headerlink" title="位移："></a>位移：</h4></li></ul><blockquote><p>将元素向指定方向移动，类似于<code>position:relative</code>；</p></blockquote><p>赋值方式：</p><ol><li><p><code>transform:translate(100px)</code>:不加X或y轴，则默认X轴移动;</p></li><li><p><code>transform:translateX(100px)</code>：x轴移动；</p></li><li><p><code>transform:translateY(200px)</code>：y轴移动；</p></li><li><p><code>transform:translate(100px,100px)</code>:对角移动</p></li></ol><p><font color="red">设置一个值，表示向x轴移动</font><br><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210803203711.gif?ynotemdtimestamp=1628035839008" alt="位移"></p><ul><li><h4 id="缩放："><a href="#缩放：" class="headerlink" title="缩放："></a>缩放：</h4></li></ul><blockquote><p>元素根据中心原点对元素进行缩放。默认值为1</p></blockquote><p>赋值方式：</p><ol><li><p><code>transform:scale(.5)</code>:不加X或y轴，默认代表X和y轴;</p></li><li><p><code>transform:scaleX(.5)</code>：x轴缩放；</p></li><li><p><code>transform:scaleY(.5)</code>：y轴缩放；</p></li></ol><p><font color="red">设置一个值，表示x轴和y轴同时缩放</font></p><p><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/20210803203643.gif?ynotemdtimestamp=1628035839008" alt="缩放"></p><ul><li><h4 id="旋转："><a href="#旋转：" class="headerlink" title="旋转："></a>旋转：</h4></li></ul><blockquote><p>通过指定的角度参数对元素根据对象原点指定一个2D旋转。</p></blockquote><p>赋值方式：</p><ol><li><p><code>transform:rotate(30deg)</code>:不加X或y轴，默认以中心点旋转;</p></li><li><p><code>transform:rotateX(30deg)</code>：x轴旋转；</p></li><li><p><code>transform:rotateY(30deg)</code>：y轴旋转；</p></li></ol><p><font color="red">注意：只能接受一个值，设置两个值语法报错设置一个值，表示以中心点旋转</font><br><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/2D%E6%97%8B%E8%BD%AC.gif?ynotemdtimestamp=1628035839008" alt="旋转"></p><ul><li><h4 id="倾斜："><a href="#倾斜：" class="headerlink" title="倾斜："></a>倾斜：</h4></li></ul><blockquote><p>将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。</p></blockquote><p>赋值方式：</p><ol><li><p><code>transform:skew(45deg)</code>:不加x或y轴，默认代表x轴;</p></li><li><p><code>transform:skew(45deg)</code>：x轴旋转；</p></li><li><p><code>transform:skew(45deg)</code>：y轴旋转；</p></li></ol><p><font color="red">设置一个值，表示水平方向倾斜</font></p><p><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/2D%E5%80%BE%E6%96%9C.gif?ynotemdtimestamp=1628035839008" alt="倾斜"></p><h4 id="2D变形必须结合transition属性使用，即必须有触发条件（鼠标点击、鼠标划入…）"><a href="#2D变形必须结合transition属性使用，即必须有触发条件（鼠标点击、鼠标划入…）" class="headerlink" title="2D变形必须结合transition属性使用，即必须有触发条件（鼠标点击、鼠标划入…）"></a>2D变形必须结合<code>transition</code>属性使用，即必须有触发条件（鼠标点击、鼠标划入…）</h4><hr><h2 id="3D变换与3D动画："><a href="#3D变换与3D动画：" class="headerlink" title="3D变换与3D动画："></a>3D变换与3D动画：</h2><h3 id="3D变换："><a href="#3D变换：" class="headerlink" title="3D变换："></a>3D变换：</h3><blockquote><p>3D区别于2D的地方在于近大远小。</p></blockquote><h4 id="景深：（perspective）"><a href="#景深：（perspective）" class="headerlink" title="景深：（perspective）"></a>景深：（<code>perspective</code>）</h4><p>景深的作用即是设置元素与视线的距离感，即近大远小。 设置景深主要有两种方法：</p><ol><li><code>perspective: 1200px;</code>（在父元素中使用)</li><li><code>transform:perspective(1200px)</code> （在子元素中使用）</li></ol><p><font color="red">两个同时设置会发生冲突，通常数值在900-1200之间。</font></p><h4 id="变换原点："><a href="#变换原点：" class="headerlink" title="变换原点："></a>变换原点：</h4><p>同上方2D方法相同，不在赘述。</p><h4 id="实现3D场景："><a href="#实现3D场景：" class="headerlink" title="实现3D场景："></a>实现3D场景：</h4><p>需要在父元素添加<code>transform-style:preserve-3d</code>属性。</p><h5 id="transform有关3D属性："><a href="#transform有关3D属性：" class="headerlink" title="transform有关3D属性："></a><code>transform</code>有关3D属性：</h5><ul><li><h5 id="3D位移-translate3d-tx-ty-tz-translateZ"><a href="#3D位移-translate3d-tx-ty-tz-translateZ" class="headerlink" title="3D位移:translate3d(tx,ty,tz)/translateZ()"></a>3D位移:<code>translate3d(tx,ty,tz)/translateZ()</code></h5></li></ul><p><font color="red"><code>translate3d(tx,ty,tz)</code>必须添加三个值，且不能为百分比否则无效。</font></p><ul><li><h5 id="3D-旋转：rotate3d-rotateZ"><a href="#3D-旋转：rotate3d-rotateZ" class="headerlink" title="3D 旋转：rotate3d()/rotateZ()"></a>3D 旋转：<code>rotate3d()/rotateZ()</code></h5></li></ul><p><code>rotate3d()</code>需要四个值，前三个值为矢量值，建议取1和0；1代表哪一个轴旋转，最后一个值指定角度。</p><ul><li><h5 id="3D-缩放：scale3d-scaleZ"><a href="#3D-缩放：scale3d-scaleZ" class="headerlink" title="3D 缩放：scale3d()/scaleZ()"></a>3D 缩放：<code>scale3d()/scaleZ()</code></h5></li></ul><h4 id="倾斜会改变元素形状，而旋转不会改变元素形状。"><a href="#倾斜会改变元素形状，而旋转不会改变元素形状。" class="headerlink" title="倾斜会改变元素形状，而旋转不会改变元素形状。"></a><font color="red">倾斜会改变元素形状，而旋转不会改变元素形状。</font></h4><h3 id="3D动画："><a href="#3D动画：" class="headerlink" title="3D动画："></a>3D动画：</h3><h4 id="关键帧："><a href="#关键帧：" class="headerlink" title="关键帧："></a>关键帧：</h4><p>3D动画不同于过渡只能定义首尾状态，关键帧可以定义任意个状态，由此实现更复杂动画。创建方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes move&#123;</span><br><span class="line">    0%&#123;初始时状态&#125;</span><br><span class="line">    /*中间可以添加任意关键帧*/</span><br><span class="line">    100%&#123;最终状态&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完动画后就要使要改变的元素引用该动画。</p><h4 id="动画属性（animation）"><a href="#动画属性（animation）" class="headerlink" title="动画属性（animation）:"></a>动画属性（<code>animation</code>）:</h4><h5 id="相关属性：-1"><a href="#相关属性：-1" class="headerlink" title="相关属性："></a>相关属性：</h5><ul><li><code>animation-name</code>：检索或设置动画名称，与<code>@keyframes</code>配合使用；</li><li><code>animation-duration</code>：同<code>transition</code>相同。</li><li><code>animation-timing-function</code>：同<code>transition</code>相同，增加<code>step-start</code>：马上跳到动画每一帧结束状态；</li><li><code>animation-delay</code>：同<code>transition</code>相同。</li><li><code>animation-iteration-count</code>：设置或检索动画循环次数<ul><li><code>infinite</code>：无限循环;</li><li><code>number</code>：具体次数；</li></ul></li><li><code>animation-direction</code>：检索或设置动画是否反向运动<ul><li><code>reverse</code> ：反向运动</li><li><code>alternate</code>：先正向运动再反向运动，并交替循环；</li></ul></li><li><code>animation-play-state</code>：检索或设置对象状态<ul><li><code>paused</code>暂停；</li><li><code>running</code>：运动</li><li><code>animation-play-state</code>：鼠标经过时停止，移开时继续。</li></ul></li></ul><p>由上可以看出<code>animation</code>和<code>transition</code>类似，那二者有什么异同点呢？</p><h4 id="变换与动画比较："><a href="#变换与动画比较：" class="headerlink" title="变换与动画比较："></a>变换与动画比较：</h4><table><thead><tr><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td>随着时间改变元素的css属性值</td><td><code>transition</code>需要触发一个事件，才会随时间改变css属性值</td></tr><tr><td></td><td><code>animation</code>不需要触发任何事件</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;过渡-transition-：&quot;&gt;&lt;a href=&quot;#过渡-transition-：&quot; class=&quot;headerlink&quot; title=&quot;过渡(transition)：&quot;&gt;&lt;/a&gt;过渡(&lt;code&gt;transition&lt;/code&gt;)：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CSS3允许属性在一定时间内平滑过渡，过渡需要添加触发条件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;相关属性值：&quot;&gt;&lt;a href=&quot;#相关属性值：&quot; class=&quot;headerlink&quot; title=&quot;相关属性值：&quot;&gt;&lt;/a&gt;相关属性值：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;transition-property&lt;/code&gt;：检索或设置对象参与过渡的属性值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;transition-duration&lt;/code&gt;：检索或设置对象过渡持续时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;transition-delay&lt;/code&gt;:检索或设置对象延迟过渡时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;transition-timing-function&lt;/code&gt;:检索或设置对象过渡动画类型；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://www.swiftslee.me/categories/CSS/"/>
    
    
    <category term="动画" scheme="http://www.swiftslee.me/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>img三像素</title>
    <link href="http://www.swiftslee.me/2021/07/29/img%E4%B8%89%E5%83%8F%E7%B4%A0/"/>
    <id>http://www.swiftslee.me/2021/07/29/img%E4%B8%89%E5%83%8F%E7%B4%A0/</id>
    <published>2021-07-29T12:37:51.912Z</published>
    <updated>2021-08-21T03:36:27.726Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h1 id="怎样解决img标签在严格模式下渲染会有三像素空白问题？"><a href="#怎样解决img标签在严格模式下渲染会有三像素空白问题？" class="headerlink" title="怎样解决img标签在严格模式下渲染会有三像素空白问题？"></a>怎样解决<code>img</code>标签在严格模式下渲染会有三像素空白问题？</h1><p>由于基线对齐，因此若img标签有父元素嵌套（block），图片下方会多出三像素，可采用以下解决方案：</p><ul><li><p>img标签增加<code>vertical-align:top/middle/bottom</code>；</p></li><li><p>img标签的父标签增加<code>font-size:0</code>；</p></li><li><p>img标签增加<code>display:block</code>；</p><span id="more"></span><p>三像素示意图：</p><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/img%E5%83%8F%E7%B4%A0.png" style="zoom: 33%;"></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h1 id=&quot;怎样解决img标签在严格模式下渲染会有三像素空白问题？&quot;&gt;&lt;a href=&quot;#怎样解决img标签在严格模式下渲染会有三像素空白问题？&quot; class=&quot;headerlink&quot; title=&quot;怎样解决img标签在严格模式下渲染会有三像素空白问题？&quot;&gt;&lt;/a&gt;怎样解决&lt;code&gt;img&lt;/code&gt;标签在严格模式下渲染会有三像素空白问题？&lt;/h1&gt;&lt;p&gt;由于基线对齐，因此若img标签有父元素嵌套（block），图片下方会多出三像素，可采用以下解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;img标签增加&lt;code&gt;vertical-align:top/middle/bottom&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;img标签的父标签增加&lt;code&gt;font-size:0&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;img标签增加&lt;code&gt;display:block&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="图片bug" scheme="http://www.swiftslee.me/categories/%E5%9B%BE%E7%89%87bug/"/>
    
    
    <category term="CSS" scheme="http://www.swiftslee.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局之文档流浮动与定位</title>
    <link href="http://www.swiftslee.me/2021/07/22/CSS%E5%B8%83%E5%B1%80/"/>
    <id>http://www.swiftslee.me/2021/07/22/CSS%E5%B8%83%E5%B1%80/</id>
    <published>2021-07-22T11:37:23.580Z</published>
    <updated>2021-08-21T03:35:48.535Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul><li>普通流（文档流）：自上而下，自左向右显示。</li><li>定位</li><li>浮动<h2 id="CSS浮动介绍："><a href="#CSS浮动介绍：" class="headerlink" title="CSS浮动介绍："></a>CSS浮动介绍：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float:left;左浮动</span><br><span class="line">float:right;右浮动</span><br></pre></td></tr></table></figure><span id="more"></span>众所周知，块级元素在页面独占一行，即自上而下排列，如下图：<br><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/%E6%B5%AE%E5%8A%A81.png" alt="浮动1"><br>这就是所谓的标准文档流，因此想脱离文档流，让块级元素在一行显示就必须使用浮动。<blockquote><p>浮动就是脱离文档流，漂浮在文档流之上。</p></blockquote><h2 id="浮动折叠："><a href="#浮动折叠：" class="headerlink" title="浮动折叠："></a>浮动折叠：</h2>由于浮动元素会在其他元素上方，因此会造成遮挡问题，如下图：<br><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/%E6%B5%AE%E5%8A%A82.png" alt="浮动2"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: gold;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.div2&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>div1</code>设置左浮动后，<code>div2</code>移到上方。原因是<code>div1</code>脱离文档流，因此位置变为空，<code>div2</code>就会移到上方。</p><h6 id="由此可知，浮动会导致重叠，那下方div2浮动后会不会在div1的位置呢？"><a href="#由此可知，浮动会导致重叠，那下方div2浮动后会不会在div1的位置呢？" class="headerlink" title="由此可知，浮动会导致重叠，那下方div2浮动后会不会在div1的位置呢？"></a>由此可知，浮动会导致重叠，那下方<code>div2</code>浮动后会不会在<code>div1</code>的位置呢？</h6><p><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/%E6%B5%AE%E5%8A%A83.png" alt="浮动3"><br>答案是不会，<code>div3</code>会在<code>div2</code>的位置，而<code>div2</code>位置则不会变。</p><h3 id="因为div2浮动不会造成文字浮动，此时文字第div1和div2在同一层级，因此div2不会浮动。"><a href="#因为div2浮动不会造成文字浮动，此时文字第div1和div2在同一层级，因此div2不会浮动。" class="headerlink" title="因为div2浮动不会造成文字浮动，此时文字第div1和div2在同一层级，因此div2不会浮动。"></a>因为<code>div2</code>浮动不会造成文字浮动，此时文字第div1和<code>div2</code>在同一层级，因此<code>div2不会浮动</code>。</h3><h3 id="浮动不会覆盖同级元素，因此文字中和图片不会被覆盖-。"><a href="#浮动不会覆盖同级元素，因此文字中和图片不会被覆盖-。" class="headerlink" title="浮动不会覆盖同级元素，因此文字中和图片不会被覆盖 。"></a><font color="red">浮动不会覆盖同级元素，因此文字中和图片不会被覆盖 。</font></h3><hr><h2 id="CSS定位："><a href="#CSS定位：" class="headerlink" title="CSS定位："></a>CSS定位：</h2><p><code>position</code>属性：</p><ul><li> <code>relative</code>:相对定位，相对于自身位置进行定位，且不脱离文档流且占位。</li><li> <code>absolute</code>:绝对定位，相对于最近有定位的父元素进行定位（若父元素没有定位，则根据html定位）,脱离文档流且不占位。</li><li> <code>fixed</code>：固定定位，相对于可视窗口定位，脱离文档流且不占位。</li><li> <code>stick</code>：粘性定位，当页面未滚出父元素，表现和<code>relative</code>相同，反之和<code>fixd</code>相同。</li></ul><h2 id="高度塌陷："><a href="#高度塌陷：" class="headerlink" title="高度塌陷："></a>高度塌陷：</h2><p>高度塌陷指容器内子元素添加浮动属性，而容器本身不浮动。容器相当于浮动元素不存在的现象。</p><p><img src="https://raw.githubusercontent.com/lcrazyl/image/master/image/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7.gif" alt="高度塌陷"></p><h2 id="解决高度塌陷常用方法："><a href="#解决高度塌陷常用方法：" class="headerlink" title="解决高度塌陷常用方法："></a>解决高度塌陷常用方法：</h2><ul><li><ol><li>容器元素添加<code>overflow：hidden</code></li></ol></li></ul><p>缺点：IE6以下不兼容；不能和<code>position</code>属性共存，超出的尺寸会被隐藏。</p><ul><li><ol start="2"><li>在浮动元素下方添加一个空<code>div</code>,并声明<code>clear:both</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear:both;</span><br><span class="line">  /*防止空标签内有数据 */</span><br><span class="line">height:0;</span><br><span class="line">overflow:hidden;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p> 缺点：需要添加多余的空标签并添加属性。</p><ul><li><ol start="3"><li>父元素添加浮动。</li></ol></li></ul><p> 缺点：产生新的浮动。</p><ul><li><ol start="4"><li>最佳方法：添加<code>::after</code>；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.clearfn::after&#123;</span><br><span class="line">  content:&quot;&quot;</span><br><span class="line">  display: block;</span><br><span class="line">  clear: both;</span><br><span class="line">  height: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&lt;!-- visibility:hidden;为了去隐藏content中的内容  --&gt;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;!-- 兼容IE7添加zoom--&gt;</span><br><span class="line">.clearfn&#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">        &#125;      </span><br></pre></td></tr></table></figure></li></ol></li></ul><p>缺点：IE7以下不兼容；代码过多。</p><h2 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h2><blockquote><p> Block Formatting Contexts（BFC），块级元素格式化上下文。它是一个独立的渲染区域，只有块元素参与，它规定了内部块元素如何布局，并且与外界毫不相干。</p></blockquote><h3 id="触发条件是什么？"><a href="#触发条件是什么？" class="headerlink" title="触发条件是什么？"></a>触发条件是什么？</h3><ol><li><code>float</code>的值为<code>left/right</code>;<br></li><li><code>overflow</code>的值为<code>auto/hidden/scroll</code>;<br></li><li><code>position</code>的值为<code>absolute/fixed</code>;<br></li><li><code>display</code>的值为<code>table-cell/table-caption/inline-block</code>;<br></li><li>当前元素转换为根元素<code>display:flow-root</code>;(不推荐)<br></li></ol><h3 id="触发方式是什么？"><a href="#触发方式是什么？" class="headerlink" title="触发方式是什么？"></a>触发方式是什么？</h3><ul><li>若元素为父子关系，触发条件则添加给父元素。</li><li>若元素为兄弟关系，触发条件添加给第二个元素。</li></ul><h3 id="BFC可以解决什么问题？"><a href="#BFC可以解决什么问题？" class="headerlink" title="BFC可以解决什么问题？"></a>BFC可以解决什么问题？</h3><ol><li>高度塌陷；</li><li>margin折叠；</li><li>浮动脱离文档流；</li><li>子元素传递给父元素的<code>margin-top</code>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通流（文档流）：自上而下，自左向右显示。&lt;/li&gt;
&lt;li&gt;定位&lt;/li&gt;
&lt;li&gt;浮动&lt;h2 id=&quot;CSS浮动介绍：&quot;&gt;&lt;a href=&quot;#CSS浮动介绍：&quot; class=&quot;headerlink&quot; title=&quot;CSS浮动介绍：&quot;&gt;&lt;/a&gt;CSS浮动介绍：&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;float:left;左浮动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;float:right;右浮动&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://www.swiftslee.me/categories/CSS/"/>
    
    
    <category term="CSS布局" scheme="http://www.swiftslee.me/tags/CSS%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>标签分类</title>
    <link href="http://www.swiftslee.me/2021/07/21/%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB/"/>
    <id>http://www.swiftslee.me/2021/07/21/%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB/</id>
    <published>2021-07-21T02:15:22.112Z</published>
    <updated>2021-08-21T03:37:09.782Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h2 id="HTML常用标签分类"><a href="#HTML常用标签分类" class="headerlink" title="HTML常用标签分类"></a>HTML常用标签分类</h2><ul><li><p>行内元素：不独立成行；不能设定宽高；只嵌套文本；添加<code>margin-top/bottom</code>与<code>padding-top/bottom</code>无效。</p></li><li><p>块级元素：独立成行；可以设定其宽高；可作为其他元素的父元素（<code>p</code>标签除外）。</p></li><li><p>行内块元素：不独立成行，可改变宽高。</p><span id="more"></span></li><li><p>可变元素：即可根据上下文决定是块级元素或是行内元素，即设置display属性。</p></li><li><p>空元素：没有内容的元素即为空元素，例如<code>br</code>、<code>hr</code>、<code>input</code>、<code>img</code>、<code>link</code>。</p></li><li><p>不可替换元素：HTML大多数元素是不可替换元素，就是直接表现出来的。</p></li><li><p>可替换元素：根据元素标签和属性，决定显示内容；替换元素一般都有内在尺寸，例如<code>img</code>、<code>input</code>。</p></li></ul><blockquote><p>HTML标签大致可分为行内元素和块级元素，其他分类都是细分或根据不同角度进行分类，因此我们只讨论常用的行内元素和常用的块级元素。</p></blockquote><h3 id="常用行内元素有哪些？"><a href="#常用行内元素有哪些？" class="headerlink" title="常用行内元素有哪些？"></a>常用行内元素有哪些？</h3><ul><li><code>a</code> - 超链接</li><li><code>i</code> - 斜体</li><li><code>img</code> - 图片（行内块元素）</li><li><code>input</code> - 输入框(行内块元素)</li><li><code>label</code> - 表格标签</li><li><code>select</code> - 项目选择</li><li><code>span</code> - 定义文本区块</li><li><code>textarea</code> - 多行文本输入框</li></ul><h3 id="常用块级元素-有哪些？"><a href="#常用块级元素-有哪些？" class="headerlink" title="常用块级元素 有哪些？"></a>常用块级元素 有哪些？</h3><ul><li><code>div</code> - 常用块级</li><li><code>dl</code> - 自定义列表</li><li><code>fieldset</code> - form控制组</li><li><code>form</code> - 交互表单</li><li><code>h1</code>-<code>h6</code>-标题</li><li><code>hr</code> - 水平分隔线</li><li><code>menu</code> - 菜单列表</li><li><code>ol</code> - 有序表单</li><li><code>p</code> - 段落</li><li><code>table</code> - 表格</li><li><code>ul</code> - 无序列表</li></ul><hr><h3 id="img真的是行内元素吗？"><a href="#img真的是行内元素吗？" class="headerlink" title="img真的是行内元素吗？"></a><code>img</code>真的是行内元素吗？</h3><p>​    既然是行内元素为什么可以设置宽高呢？<strong>其实<code>img</code>属于替换元素，其内有设置宽高属性。</strong></p><p>​    <code>img</code>标签同时具有行内、行内块和块级元素特性。</p><hr><h3 id="行内元素如何转为块元素？"><a href="#行内元素如何转为块元素？" class="headerlink" title="行内元素如何转为块元素？"></a>行内元素如何转为块元素？</h3><ul><li>添加<code>display</code>属性：<code>display:block</code>；</li><li>添加定位：<code>position:absolute/fixed</code>；</li><li>添加浮动:<code>float:left/right/center</code>；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;h2 id=&quot;HTML常用标签分类&quot;&gt;&lt;a href=&quot;#HTML常用标签分类&quot; class=&quot;headerlink&quot; title=&quot;HTML常用标签分类&quot;&gt;&lt;/a&gt;HTML常用标签分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;行内元素：不独立成行；不能设定宽高；只嵌套文本；添加&lt;code&gt;margin-top/bottom&lt;/code&gt;与&lt;code&gt;padding-top/bottom&lt;/code&gt;无效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;块级元素：独立成行；可以设定其宽高；可作为其他元素的父元素（&lt;code&gt;p&lt;/code&gt;标签除外）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行内块元素：不独立成行，可改变宽高。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="HTML" scheme="http://www.swiftslee.me/categories/HTML/"/>
    
    
    <category term="HTML标签" scheme="http://www.swiftslee.me/tags/HTML%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>即将</title>
    <link href="http://www.swiftslee.me/2021/07/12/%E5%8D%B3%E5%B0%86/"/>
    <id>http://www.swiftslee.me/2021/07/12/%E5%8D%B3%E5%B0%86/</id>
    <published>2021-07-12T02:19:07.785Z</published>
    <updated>2021-08-14T07:57:11.995Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">请输入密码</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19MTqvLSMlZxjghT+jEpLq/++nZLR6Kh8Y5WwzcWh6e4T+2skgp2am3WjSi+LGFMloF1KxeBiHj0xC044uPMYsn4U5aQhE8LdjB4SnEOo9oSrf37rFV3m5e9M4GHywQ+EAiNamAHa07S5yL50OJtDUXZrUuFOSHV+yegveNVny/SffNbySgPBmsY05HlqLXn82NtF7Wax/kNdBXkJfFXujeztXpRJ2oN9qfRkVwlJqZTeHycn5cSkndRwVe6M1LFPszvcS5R+aOCGWUL56Zkg0tn+uWaRiKtcOIOzonIQU8q5SrSi5wpWuRR6O/b7hymnUJ0oyqGst/bRzJsofxRgIIw8lg1nGZFVPL1tlmuVTBXuo8hkpyPEasa5Ma2MdSgf4jW6kBrtFPrYAP+RQvbEtXycSlLzF1GgB1w3BpjeDtk++K9byxP8vqxVEqKxkH0gCvCL7VYOTT3iRPQRdI9C6EvCSvSee7fcA5dBw80wrInfz0TdtXPm23LnyBu0r7IM3LkgC1XVRxhyA8dRIlX8r1/o0tRgBVkIvyRoSr+QPWOFHW9GJ3mkqjSSdhqEe9yI103A/b5uQO362FVCCsmKsY/zkfp6kfK9OanEmpVPx13vSkZJctttEbWh6QhGZSM74tXWFnBq+UcgDPMhgpqXccccI2LPPjcgFrFgg2Es3H9sitY3CZQWwt1aOCIyN3eOIn0Yjf3FxYyOBYjccvGPdTw1kJmQ+3meWCXYWLvmQqqDOqcLUIOawIoEyO1ObsFomfJiS3N5I7BlgSyqVAFN/IctpxEHMzvUNBibaopC+aDl+oDgZpOXhFOGM8zQY9+rgHqDe5scNoJPZD56oU//12h9wqdCJUQzuS8+Rf4xmdSVe6aZW8dhBJfbmpXtSHNbtlQwZbP9XtTwIT6y2cBpGgH3LFo74M1mZT2008Pq49f9iLG6FEQjg9ueuY4iFCFrmHgV20HE44vTE3hKCX56mjLIYkGLD/mR0= </div>]]></content>
    
    
    <summary type="html">The article has been encrypted, please enter your password to view.&lt;br&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://www.swiftslee.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://www.swiftslee.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>安好</title>
    <link href="http://www.swiftslee.me/2021/07/12/%E5%AE%89%E5%A5%BD/"/>
    <id>http://www.swiftslee.me/2021/07/12/%E5%AE%89%E5%A5%BD/</id>
    <published>2021-07-12T02:00:52.972Z</published>
    <updated>2021-08-21T03:37:13.395Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><center>媚眼含羞合，丹唇逐笑开。风卷葡萄带，日照石榴裙。</center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;-&lt;/p&gt;
&lt;center&gt;媚眼含羞合，丹唇逐笑开。风卷葡萄带，日照石榴裙。
&lt;/center&gt;</summary>
      
    
    
    
    <category term="随笔" scheme="http://www.swiftslee.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://www.swiftslee.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
